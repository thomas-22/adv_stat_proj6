---
title: "Report"
author: "Group"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r source_all, echo=FALSE}
source("source_all.R")
```

```{r read data}
Pregnancy <- prep.Pregnancy.data()
Movement <- prep.Movement.data()
HuntEvents <- prep.HuntEvents.data()
FCMStress <- prep.FCMStress.data()

data_full <- AssignFCMData(FCMStress, Movement, HuntEvents)
# View(data_full)

# # save as RDS
# saveRDS(Pregnancy, "Data/intermediate/Pregnancy.RDS")
# saveRDS(Movement, "Data/intermediate/Movement.RDS")
# saveRDS(HuntEvents, "Data/intermediate/HuntEvents.RDS")
# saveRDS(FCMStress, "Data/intermediate/FCMStress.RDS")
```

### Models

```{r}
library(mgcv)
library(ggeffects)

data_closest_time <- FilterData(
  data_full,
  gut.retention.hours = 10,
  k = 10
) %>% filter(DistanceY <= 30)

# distribution of number of hunting events within previous k days
data_closest_time %>% ggplot() +
  geom_bar(aes(x = nOtherHuntEvents))

summary(data_closest_time)
# View(data_closest_time)

lm_naive <- lm(
  ng_g ~ Distance + TimeDiff + lognHuntEvents + SampleDelay + Season,
  data = data_closest_time
)
summary(lm_naive)

# Generate diagnostic plots
par(mfrow=c(2,2))
plot(lm_naive)
# QQ plot shows that the distributional assumption is probably wrong

# Collinearity? Not really.
car::vif(lm_naive)


# Go additive
gam_gaussian <- gam(
  ng_g ~ s(Distance, bs = "ps") + s(TimeDiff, bs = "ps") +
    s(SampleDelay, bs = "ps") +
    nOtherHuntEvents + Season,
  data = data_closest_time,
  family = gaussian()
)
summary(gam_gaussian)
plot(gam_gaussian, page = 1)
gam.check(gam_gaussian)

gam_gamma <- gam(
  ng_g ~ s(Distance, bs = "ps") + s(TimeDiff, bs = "ps") +
    s(SampleDelay, bs = "ps") + lognHuntEvents + Season,
  data = data_closest_time,
  family = Gamma(link = log)
)
summary(gam_gamma)
plot(gam_gamma, pages = 1)
gam.check(gam_gamma)
# Is this QQ plot better?

# Consider distance in X,Y directions separately
gam_gamma_xy <- gam(
  ng_g ~ s(DistanceX, bs = "ps") + s(DistanceY, bs = "ps") + s(TimeDiff, bs = "ps") +
    s(SampleDelay, bs = "ps") + nOtherHuntEvents + Season,
  data = data_closest_time,
  family = Gamma(link = log)
)
summary(gam_gamma_xy)
plot(gam_gamma_xy, page = 1)
gam.check(gam_gamma_xy)

# plot FCM level against one variable with other variables held constant
predict_response(gam_gamma_xy, terms = "DistanceX") %>% plot()
predict_response(gam_gamma_xy, terms = "DistanceY") %>% plot()
predict_response(gam_gamma_xy, terms = "TimeDiff") %>% plot()
predict_response(gam_gamma_xy, terms = "SampleDelay") %>% plot()

# Does gamlss help?
gamlss_gaussian <- gam(
  list(
    # mean
    ng_g ~ s(DistanceX, bs = "ps") + s(DistanceY, bs = "ps") + s(TimeDiff, bs = "ps") +
      s(SampleDelay, bs = "ps") + nOtherHuntEvents + Season,
    # variance
    ~ s(DistanceX, bs = "ps") + s(DistanceY, bs = "ps") + s(TimeDiff, bs = "ps") +
      s(SampleDelay, bs = "ps") + nOtherHuntEvents + Season
  ),
  data = data_closest_time,
  family = gaulss()
)
summary(gamlss_gaussian)
plot(gamlss_gaussian, pages = 1, scale = 0)
gam.check(gamlss_gaussian)
# But Gaussianity assumption is violated according to QQ plot

# DOES NOT WORK
# gamlss_gamma <- gam(
#   list(
#     # mean
#     ng_g ~ s(DistanceX, bs = "ps") + s(DistanceY, bs = "ps") + s(TimeDiff, bs = "ps") +
#       s(SampleDelay, bs = "ps") + nOtherHuntEvents + Season,
#     # variance
#     ~ nOtherHuntEvents + Season
#   ),
#   data = data_closest_time,
#   family = gammals()
# )
```

### Notes

```{r}
# Distribution of hunting events throughout the day now looks reasonable
HuntEvents %>%
  filter(!is.na(HuntTime)) %>%
  mutate(HuntHour = hour(HuntTime)) %>%
  ggplot() +
  geom_bar(aes(x = HuntHour), just = 0) +
  labs(x = "Hour of day")
```

### Legacy

The following code blocks are from Niko. They probably no longer work. Tell me if you still need them. --Baisu.

```{r visualize data}
head(model.data)

model.data %>%
  ggplot()+
  geom_bar(aes(x = forcats::fct_reorder(Sender.ID, as.numeric(group)), fill = group)) +
  guides(x = guide_axis(angle = 60)) +   
  labs(y="observations", x="Deer", title = "Number of observations per deer and herd") 

model.data %>%
  ggplot() +
  geom_mosaic(aes(x = product(group, pregnant), fill = group)) +   
  labs(y="Herd", x="Pregnant?", title = "Herds and pregnant deer in the model data") +
  guides(fill = "none")
```


<!-- 
```{r initial modelling}
simple.model <- lm(ng_g ~., data = model.data)
summary(simple.model)

mod <- lm(ng_g ~ TimeDiff * I(1/Distance), data = model.data)
summary(mod)

random.intercept.model <- lmer(ng_g ~ TimeDiff + Distance + (1 | group/Sender.ID) + (1 | pregnant), data = model.data)

random.slope.model <- lmer(ng_g ~ (TimeDiff + Distance | Sender.ID) + 
                             #(TimeDiff + Distance | pregnant) +
                             (1 | pregnant), 
                           data = model.data)

summary(random.intercept.model)
```


```{r diagnosis of initial modelling}
model.data.augmented <- model.data %>%
  mutate(simple.model = predict(simple.model, model.data),
         even.simpler.model = predict(mod, model.data),
         random.intercept.model = predict(random.intercept.model, model.data),
         random.slope.model = predict(random.slope.model, model.data),
         Sample_ID = data.full$Sample_ID) %>%
  pivot_longer(c(even.simpler.model, simple.model, random.intercept.model, random.slope.model),
               values_to = ".fit",
               names_to = "model") %>%
  mutate(.resid = ng_g - .fit)

RMSEs <- model.data.augmented %>%
  group_by(model) %>%
  summarise(RMSE = sqrt(mean(.resid^2)))

ggplot(model.data.augmented, aes(color = model)) +
  stat_qq_line(aes(sample = .resid), color = "black") + 
  stat_qq(aes(sample = .resid), alpha = .7, size = 1) + 
  theme_light() +
  labs(y = "Residuals", x = "theoretical Quantiles", title = "QQ-Plots of different model fits") +
  ggrepel::geom_label_repel(data = RMSEs, aes(label = sprintf("RMSE: %.2f", RMSE), x = 2, y = -150), direction = "y", force = .5) 

ggplot(model.data.augmented, aes(color = model)) +
  geom_point(aes(x = .fit, y = .resid)) +
  geom_hline(yintercept = 0, color = "black") +
  labs(y = "Residuals",x = "fitted values", title = "Residuals vs fitted values") +
  facet_wrap(~model, nrow = 3) +
  guides(color = "none")


ggplot(model.data.augmented, aes(color = model)) +
  geom_point(aes(x = ng_g, y = .fit), alpha = .5, size = 1) +
  geom_smooth(aes(x = ng_g, y = .fit), method = "lm", se = FALSE) +
  geom_abline(slope = 1) +
  labs(x = "actual", y = "predicted")
```
-->
